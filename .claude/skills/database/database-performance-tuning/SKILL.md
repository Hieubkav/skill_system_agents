---
name: database-performance-tuning
description: Analyze and optimize database performance through index analysis, query profiling, and EXPLAIN plan interpretation. Identify missing/unused indexes, find bottlenecks, and recommend optimization strategies. Use when optimizing slow queries, analyzing workloads, improving query execution speed, or managing database indexes.
allowed-tools: Read, Write, Edit, Grep, Glob, Execute
version: 1.0.0
---

# Database Performance Tuning

## Level 1: Overview

Comprehensive database performance analysis covering index optimization and query profiling to enhance database speed and efficiency.

## Prerequisites

- Database access with SELECT privileges
- Slow query logs or performance monitoring enabled
- Understanding of database schema and query patterns

## What This Skill Does

1. Analyzes query patterns and existing index configurations
2. Identifies missing indexes that would improve performance
3. Finds unused indexes that waste storage and slow writes
4. Interprets EXPLAIN plans to find bottlenecks
5. Provides specific optimization recommendations and SQL fixes

---

## Level 2: Quick Start

### Basic Workflow

**Step 1: Identify slow queries**
```sql
-- Enable slow query logging
-- Find queries taking > 2 seconds
```

**Step 2: Analyze with EXPLAIN**
```sql
EXPLAIN ANALYZE your_slow_query;
-- Look for: Seq Scan, high cost, many rows
```

**Step 3: Add strategic indexes**
```sql
-- Create indexes on WHERE, JOIN, ORDER BY columns
CREATE INDEX idx_name ON table(column);
```

**Step 4: Verify improvement**
```sql
-- Re-run EXPLAIN to confirm optimization
EXPLAIN ANALYZE your_slow_query;
```

### Key Metrics

- **Seq Scan** → Full table scan (slow, needs index)
- **Index Scan** → Using index (good)
- **Index Only Scan** → Index contains all data (best)
- **Cost** → Lower is better
- **Rows** → Fewer is better

---

## Common Use Cases

### Case 1: Optimize Slow SELECT Query
Query taking 5 seconds. Run EXPLAIN, identify missing index on WHERE clause, create index, verify query now runs in 50ms.

### Case 2: Remove Unused Indexes
Database has 50 indexes but only 30 are used. Identify unused ones, verify not needed for constraints, drop them to improve write performance.

### Case 3: Fix N+1 Query Problem
Application makes 1000 queries in loop. Rewrite to use JOINs or batch loading, reducing to 1 query.

---

## Best Practices

1. **Index Management**
   - Index WHERE, JOIN, ORDER BY columns
   - Use composite indexes for multi-column filters
   - Remove unused indexes
   - Don't over-index (slows writes)

2. **Query Optimization**
   - Select only needed columns (not SELECT *)
   - Filter before joining
   - Use LIMIT for pagination
   - Avoid functions on indexed columns

3. **Maintenance**
   - Run ANALYZE regularly to update statistics
   - VACUUM to reclaim space (PostgreSQL)
   - Monitor slow query log
   - Benchmark before and after changes

---

## Common Bottlenecks

- **Missing Indexes** → Full table scans
- **Inefficient JOINs** → Large row counts
- **N+1 Queries** → Loop queries
- **Large Result Sets** → No pagination
- **Complex Subqueries** → Nested scans
- **Unused Indexes** → Slow writes

---

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Query still slow after index | Check if index is actually used (EXPLAIN) |
| Index not being used | Ensure column data types match, avoid functions |
| Write performance degraded | Too many indexes, remove unused ones |
| Out of memory | Reduce result set size, add LIMIT |
| Deadlocks | Review transaction isolation levels |

---

## Integration

- **Monitoring Tools** - New Relic, Datadog, Prometheus
- **Query Logging** - Slow query logs for identifying problems
- **Load Testing** - Use with load testing to find limits
- **ORM Integration** - Understand queries generated by ORM
